{
    "scrape_url": "https://scrape.pastebin.com/api_scrape_item.php?i=k1Kdt20v",
    "full_url": "https://pastebin.com/k1Kdt20v",
    "date": "1594498233",
    "key": "k1Kdt20v",
    "size": 6852,
    "expire": "0",
    "title": "nav.lua",
    "syntax": "lua",
    "user": "",
    "filename": "k1Kdt20v",
    "pasteid": "k1Kdt20v",
    "pastesite": "pastebin.com",
    "@timestamp": "2020-07-11T20:10:33",
    "MD5": "7ae2385cd2de0b35f8df504ac94a02f7",
    "SHA256": "ffe2c0480ca45019a3a1396f1952fcb586872dcb1490c0d3a7597ad4f1258e64",
    "raw_paste": "os.loadAPI(\"general.lua\")\n\nNORTH  = 0 -- -z\nEAST   = 1 -- +x\nSOUTH  = 2 -- +z\nWEST   = 3 -- -x\n\nCHANNEL_MINING_STATUS = 51\nCHANNEL_CLONE_PANIC   = 666\n\nCOMMAND_UPDATE = \"update\"\n\nHOME_DATA = \"home.data\"\nID_DATA   = \"id.data\"\nVER_DATA  = \"version.data\"\n\nCURRENT_POS = {}\n\nfunction go_to(target, pos)\n    -- go up while pos is lower than\n    if pos == nil then\n        pos = get_pos_and_direction()\n    end\n\n    local d = pos[\"d\"]\n\n    if pos[\"y\"] < target[\"y\"] then\n        go_up(target[\"y\"] - pos[\"y\"])\n    end\n\n    if pos[\"y\"] > target[\"y\"] then\n        go_down(pos[\"y\"] - target[\"y\"])\n    end\n\n    if pos[\"x\"] < target[\"x\"] then\n        go_east(d, target[\"x\"] - pos[\"x\"])\n        d = EAST\n    end\n\n    if pos[\"x\"] > target[\"x\"] then\n        go_west(d, pos[\"x\"] - target[\"x\"])\n        d = WEST\n    end\n\n    if pos[\"z\"] < target[\"z\"] then\n        go_south(d, target[\"z\"] - pos[\"z\"])\n        d = SOUTH\n    end\n\n    if pos[\"z\"] > target[\"z\"] then\n        go_north(d, pos[\"z\"] - target[\"z\"])\n        d = NORTH\n    end\n\n    -- turn and face the desired direction\n    turn_to(d,target[\"d\"])\nend\n\nfunction go_up(dist)\n    while dist > 0 do\n        if turtle.up() then\n            dist = dist - 1\n        else\n            turtle.digUp()\n        end\n    end\nend\n\nfunction go_down(dist)\n    while dist > 0 do\n        if turtle.down() then\n            dist = dist - 1\n        else\n            turtle.digDown()\n        end\n    end\nend\n\nfunction forward(dist)\n    while dist > 0 do\n        if turtle.forward() then\n            dist = dist - 1\n        else\n            turtle.dig()\n        end\n    end\nend\n\nfunction go_north(cur_dir, dist)\n    print(\"going north \" .. dist)\n    turn_to(cur_dir, NORTH)\n    forward(dist)\nend\n\nfunction go_south(cur_dir, dist)\n    print(\"going south \" .. dist)\n    turn_to(cur_dir, SOUTH)\n    forward(dist)\nend\n\nfunction go_east(cur_dir, dist)\n    print(\"going east\" .. dist)\n    turn_to(cur_dir, EAST)\n    forward(dist)\nend\n\nfunction go_west(cur_dir, dist)\n    print(\"going west \" .. dist)\n    turn_to(cur_dir, WEST)\n    forward(dist)\nend\n\nfunction turn_to(d,new_d)\n    if d == new_d then\n        return nil\n    elseif (d + 1) % 4 == new_d then\n        turtle.turnRight()\n    elseif (d - 1) % 4 == new_d then\n        turtle.turnLeft()\n    else\n        turtle.turnLeft()\n        turtle.turnLeft()\n    end\nend\n\nfunction get_position()\n    local x,z,y = nil\n    while x == nil or x ~= x do\n        -- x ~= x checks for Not a Number, which happens sometimes\n        -- (for Reasons known to neither Man nor God)\n        x,z,y = gps.locate(10)\n        if x == nil or x ~= x then\n            print(\"gps failed. don't know why. will wait and try again\")\n            os.sleep(10)\n        end\n    end\n\n    local pos = {}\n    pos.x = x\n    pos.y = y\n    pos.z = z\n    print(\"GPS position is x\" .. pos.x ..\" z\" .. pos.z .. \" y\" .. pos.y)\n    return pos\nend\n\nfunction get_pos_and_direction()\n    \n    print(\"GETTING DIRECTION VIA GPS\")\n\n    local pos1 = get_position()\n    \n    local tries = 0 -- try to walk unobstructed 3 times before we dig\n    local moved = false\n    while not moved and tries < 3 do\n        if not turtle.forward() then\n            turtle.turnLeft()\n            tries = tries + 1\n        else\n            moved = true\n        end\n    end\n\n    if not moved then -- we didn't move yet; let's dig our way out\n        while not turtle.forward() do\n            turtle.dig()\n        end\n    end\n\n    local pos = get_position()\n    local heading = {}\n    heading.x = pos1.x - pos.x\n    heading.z = pos1.z - pos.z\n\n    if heading.x > 0 then\n        pos.d = WEST\n    end\n\n    if heading.x < 0 then\n        pos.d = EAST\n    end\n\n    if heading.z < 0 then\n        pos.d = SOUTH\n    end\n\n    if heading.z > 0 then\n        pos.d = NORTH\n    end\n\n    print(\"We're at \" .. pos.x .. \",\" .. pos.y .. \",\" .. pos.z .. \", facing \" .. pos.d)\n\n    return pos\nend\n\nfunction set_home(direction)\n    local pos = get_position()\n    pos.d = direction\n    general.write_data(HOME_DATA,pos)\n    return pos\nend\n\nfunction get_home()\n    return general.read_data(HOME_DATA)\nend\n\nfunction announce(channel, announcement)\n    print(\"Broadcasting announcement: \" .. announcement)\n    local modem = peripheral.wrap(\"left\")\n    local label = os.getComputerLabel()\n    modem.transmit(channel, 1, label .. \": \" .. announcement)\nend\n\nfunction set_identity()\n    local id = os.getComputerLabel()\n    general.write_data(ID_DATA, id)\nend\n\nfunction clone_check()\n    local actual_id = os.getComputerLabel()\n    saved_id = general.read_data(ID_DATA)\n    if saved_id ~= actual_id then\n        announce(CHANNEL_CLONE_PANIC, \"CLONE PANIC\")\n        os.exit() -- die, clone\n    end\nend\n\nfunction handle_update_command(msg)\n    -- this command should already be confirmed to be destined for this unit\n    -- check whether this command is asking us to update software\n    \n    if msg[2] ~= COMMAND_UPDATE then\n        -- not an update, carry on\n        return false\n    end\n\n    -- if it IS an update, expect a series of {file, pastebin} pairs\n    local i = 3\n    while msg[i] ~= nil do\n        local file = msg[i]\n        local paste = msg[i+1]\n\n        if fs.exists(file) then\n            fs.delete(file)\n        end\n        \n        shell.run(\"pastebin get \" .. paste .. \" \" .. file)\n        i = i + 2\n    end\n\n    -- nighty night\n    os.reboot()\nend\n\nfunction split_args(str, delim, maxNb)\n   -- Eliminate bad cases...\n    if type(str) ~= \"string\" then\n        print(\"wtf message is not string\")\n        return t\n    end\n    if string.find(str, delim) == nil then\n       return { str }\n    end\n    if maxNb == nil or maxNb < 1 then\n       maxNb = 0    -- No limit\n    end\n    local result = {}\n    local pat = \"(.-)\" .. delim .. \"()\"\n    local nb = 0\n    local lastPos\n    for part, pos in string.gfind(str, pat) do\n       nb = nb + 1\n       result[nb] = part\n       lastPos = pos\n       if nb == maxNb then\n          break\n       end\n    end\n    -- Handle the last field\n    if nb ~= maxNb then\n       result[nb + 1] = string.sub(str, lastPos)\n    end\n    return result\nend\n\nfunction get_wireless_command(channel)\n    local modem = peripheral.wrap(\"left\")\n    modem.open(channel)\n    local label = os.getComputerLabel()\n\n    while true do\n        local event, modemSide, senderChan, replyChan, msg, senderDist = os.pullEvent(\"modem_message\")\n\n        local msg_args = split_args(msg, \" \")\n        local length = table.getn(msg_args)\n\n        if length < 2 then\n            print(\"blank message I guess?\")\n        elseif msg_args[1] == label then\n            print(\"heard message for me \" .. msg)\n            if not handle_update_command(msg_args) then\n                return msg_args\n            end\n        end\n    end\nend\n\nif (arg ~= nil) then\n    print(\"update commands like 'nav x update file.lua 509qodf' where x can be whatever\")\n    handle_update_command(arg)\nend",
    "YaraRule": [
        "enable_org32",
        "core_keywords"
    ]
}