{
    "scrape_url": "https://scrape.pastebin.com/api_scrape_item.php?i=FrWxVUaB",
    "full_url": "https://pastebin.com/FrWxVUaB",
    "date": "1594635937",
    "key": "FrWxVUaB",
    "size": 8316,
    "expire": "0",
    "title": "",
    "syntax": "cpp",
    "user": "",
    "filename": "FrWxVUaB",
    "pasteid": "FrWxVUaB",
    "pastesite": "pastebin.com",
    "@timestamp": "2020-07-13T10:25:37",
    "MD5": "da00886af321ee2af45edbb7a583f9e5",
    "SHA256": "57a6d556644d9e079fd219300de58b9a6b97740daf6fb1bf42dc759374ec0874",
    "raw_paste": "\ufeff#include <iostream>\r\n#include <vector>\r\n#include <cmath>\r\n#include <iomanip>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\nconst long double pi = 3.14159265358;\r\nconst long double inf = 1e15;\r\n\r\nstruct Point {\r\n    long double x, y;\r\n\r\n    Point(long double x0 = 0, long double y0 = 0) {\r\n        x = x0;\r\n        y = y0;\r\n    }\r\n\r\n    long double dist(Point A) {\r\n        return sqrtl(abs(x - A.x) * abs(x - A.x) + abs(y - A.y) * abs(y - A.y));\r\n    }\r\n};\r\n\r\nstruct Vector {\r\n    long double x, y;\r\n\r\n    Vector(long double x0 = 0, long double y0 = 0) {\r\n        x = x0;\r\n        y = y0;\r\n    }\r\n\r\n    Vector(Point A, Point B) {\r\n        x = B.x - A.x;\r\n        y = B.y - A.y;\r\n    }\r\n\r\n    long double len() {\r\n        return sqrtl(x * x + y * y);\r\n    }\r\n\r\n    long long size() {\r\n        return (long long)x * x + (long long)y * y;\r\n    }\r\n\r\n    long double angle_ox() {\r\n        long double alpha = atan2(y, x);\r\n        if (alpha < 0) {\r\n            alpha += 2 * pi;\r\n        }\r\n        return alpha;\r\n    }\r\n\r\n    long double angle(Vector B) {\r\n        long double p1 = x * B.x + y * B.y;\r\n        long double p2 = x * B.y - y * B.x;\r\n\r\n        return abs((long double)atan2(p2, p1));\r\n    }\r\n};\r\n\r\nVector operator+(Vector a, Vector b) {\r\n    return Vector(a.x + b.x, a.y + b.y);\r\n}\r\n\r\nVector operator*(Vector a, long double k) {\r\n    return Vector(a.x * k, a.y * k);\r\n}\r\n\r\nVector operator*(long double k, Vector a) {\r\n    return Vector(a.x * k, a.y * k);\r\n}\r\n\r\nVector operator/(Vector a, long double l) {\r\n    return Vector(a.x / l, a.y / l);\r\n}\r\n\r\nVector operator-(Vector a, Vector b) {\r\n    return Vector(a.x - b.x, a.y - b.y);\r\n}\r\n\r\nbool operator==(Vector a, Vector b) {\r\n    return (a.x == b.x) && (a.y == b.y);\r\n}\r\n\r\nPoint operator+(Point A, Vector AB) {\r\n    return Point(A.x + AB.x, A.y + AB.y);\r\n}\r\n\r\nlong double operator^(Vector A, Vector B) {\r\n    // \u0432\u0435\u043a\u0442\u043e\u0440\u043d\u043e\u0435 \u043f\u0440\u043e\u0438\u0437\u0432\u0435\u0434\u0435\u043d\u0438\u0435\r\n    return A.x * B.y - A.y * B.x;\r\n}\r\n\r\nlong double operator&(Vector A, Vector B) {\r\n    // \u0441\u043a\u0430\u043b\u044f\u0440\u043d\u043e\u0435\r\n    long double one = A.x * B.x;\r\n    long double two = A.y * B.y;\r\n    return A.x * B.x + A.y * B.y;\r\n\r\n}\r\n\r\nistream& operator>> (istream& in, Point& P) {\r\n    in >> P.x >> P.y;\r\n    return in;\r\n}\r\n\r\nostream& operator<< (ostream& out, Point& P) {\r\n    out << P.x << \" \" << P.y;\r\n    return out;\r\n}\r\n\r\nstruct line {\r\n    long double a, b, c;\r\n\r\n    line(Point A, Point B) {\r\n        a = A.y - B.y;\r\n        b = B.x - A.x;\r\n        c = A.x * B.y - A.y * B.x;\r\n    }\r\n\r\n    line() {\r\n        a = 0;\r\n        b = 0;\r\n        c = 0;\r\n    }\r\n\r\n    line(long double q, long double w, long double e) {\r\n        a = q;\r\n        b = w;\r\n        c = e;\r\n    }\r\n\r\n    long double dist_to_line(Point P) {\r\n        long double l = abs(a * P.x + b * P.y + c);\r\n        return l / (hypot(a, b)); // sqrt(a*a + b*b)\r\n    }\r\n\r\n\r\n    Point cord_min_dist(Point P) {\r\n        Vector norm(a, b);\r\n\r\n        norm = norm / norm.len();\r\n\r\n        long double len = dist_to_line(P);\r\n\r\n        norm = norm * len;\r\n\r\n        Point ans1, ans2;\r\n\r\n        ans1 = P + norm;\r\n\r\n        norm = norm * -1;\r\n\r\n        ans2 = P + norm;\r\n\r\n        if (dist_to_line(ans1) < dist_to_line(ans2))\r\n            return ans1;\r\n        else\r\n            return ans2;\r\n\r\n    }\r\n\r\n    Vector normal() {\r\n        return Vector(a, b);\r\n    }\r\n\r\n    Vector sonoriginal() {\r\n        return Vector(-b, a);\r\n    }\r\n\r\n    Point intersection(line A) {\r\n        if (A.a = a && A.b == b) {\r\n            if (A.c != c) {\r\n                return { -inf , -inf };\r\n            }\r\n        }\r\n        long double x = (A.b * c - b * A.c) / (A.a * b - a * A.b);\r\n        long double y = (a * A.c - A.a * c) / (A.a * b - a * A.b);\r\n        return { x, y };\r\n    }\r\n};\r\n\r\n\r\nbool angle_have_point(Point A, Point O, Point B, Point P) {\r\n    // \u0443\u0433\u043e\u043b AOB \u0442\u043e\u0447\u043a\u0430 P\r\n    Vector OA(O, A);\r\n    Vector OB(O, B);\r\n    Vector OP(O, P);\r\n\r\n    long double proiz1 = OA ^ OP;\r\n    /*if (proiz1 == 0) {\r\n    return false;\r\n    }*/ // \u0435\u0441\u043b\u0438 \u0442\u043e\u0447\u043a\u0430 \u043d\u0430 \u0441\u0442\u043e\u0440\u043e\u043d\u0435 \u0443\u0433\u043b\u0430 - \u043d\u0435 \u043f\u0440\u0435\u043d\u0430\u0434\u043b\u0435\u0436\u0438\u0442\r\n    long double proiz2 = OA ^ OB;\r\n\r\n    long double proiz3 = OB ^ OP;\r\n    long double proiz4 = OB ^ OA;\r\n    if ((proiz1 * proiz2 >= 0) && (proiz3 * proiz4 >= 0))\r\n        return true;\r\n\r\n    else\r\n        return false;\r\n\r\n}\r\n\r\nstruct polygon {\r\n    vector < Point > A;\r\n    long double S = 0; // \u043f\u043b\u043e\u0449\u0430\u0434\u044c\r\n    long double P = 0; // \u043f\u0435\u0440\u0438\u043c\u0435\u0442\u0440\r\n\r\n    polygon(vector < Point >& a) {\r\n        A = a;\r\n        S = 0;\r\n        P = 0;\r\n        init();\r\n    }\r\n\r\n    void init() {\r\n\r\n        Point Null(0, 0);\r\n\r\n        for (int i = 0; i < A.size(); i++) {\r\n            Vector F(A[i], Null);\r\n            Vector T(A[(i + 1) % A.size()], Null);\r\n            S += (F ^ T);\r\n\r\n            P += A[i].dist(A[(i + 1) % A.size()]);\r\n        }\r\n        S /= 2;\r\n        S = abs(S);\r\n\r\n        shiftA();\r\n        return;\r\n    }\r\n\r\n    void shiftA() {\r\n        // \u0432 A[0] \u0441\u0430\u043c\u0443\u044e \u043b\u0435\u0432\u0443\u044e (\u043d\u0438\u0436\u043d\u044e\u044e) \u0442\u043e\u0447\u043a\u0443\r\n\r\n        int id = 0;\r\n\r\n        for (int i = 0; i < A.size(); i++) {\r\n\r\n            if (A[i].x < A[id].x) {\r\n                id = i;\r\n                continue;\r\n            }\r\n\r\n            if (A[i].x == A[id].x) {\r\n                if (A[i].y < A[id].y) {\r\n                    id = i;\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n\r\n        vector < Point > newA;\r\n\r\n        for (int i = id; i < A.size(); i++) {\r\n            newA.push_back(A[i]);\r\n        }\r\n        for (int i = 0; i < id; i++) {\r\n            newA.push_back(A[i]);\r\n        }\r\n        A = newA;\r\n        return;\r\n    }\r\n\r\n    bool point_in_polygon(Point G) {\r\n        // \u043d\u0430\u0434\u043e \u0447\u0442\u043e\u0431\u044b \u0432 A[0] \u0441\u0430\u043c\u0443\u044e \u043b\u0435\u0432\u0443\u044e (\u043d\u0438\u0436\u043d\u044e\u044e) \u0442\u043e\u0447\u043a\u0443\r\n\r\n        int left = 1;\r\n        int right = A.size() - 1;\r\n\r\n        if (!angle_have_point(A[right], A[0], A[left], G)) {\r\n            return false;\r\n        }\r\n\r\n\r\n        while (left + 1 < right) {\r\n            int mid = (left + right) / 2;\r\n\r\n            if (angle_have_point(A[mid], A[0], A[left], G)) {\r\n                right = mid;\r\n            }\r\n            else {\r\n                left = mid;\r\n            }\r\n        }\r\n\r\n        return angle_have_point(A[0], A[right], A[left], G);\r\n    }\r\n};\r\n\r\nPoint start = 0;\r\n\r\nbool cmp(Point a, Point b) {\r\n\r\n    Vector a_start(a, start);\r\n    Vector b_start(b, start);\r\n\r\n    if ((a_start ^ b_start) == 0) {\r\n        return a.dist(start) < b.dist(start);\r\n    }\r\n\r\n    return (a_start ^ b_start) > 0;\r\n\r\n}\r\n\r\n\r\n\r\nvector < Point > convex_hull(vector < Point >& A) {\r\n    // \u043c\u0430\u0441\u0441\u0438\u0432 \u0442\u043e\u0447\u0435\u043a \u043f\u0440\u043e\u0441\u0442\u043e \u0440\u0430\u0437\u0431\u0440\u043e\u0441\u0430\u043d\u043d\u044b\u0445 \u043d\u0430 \u043f\u043b\u043e\u0441\u043a\u043e\u0441\u0442\u044c\r\n    // \u0445\u043e\u0442\u0438\u043c \u0432\u044b\u043f\u0443\u043a\u043b\u0443\u044e \u043e\u0431\u043e\u043b\u043e\u0447\u043a\u0443\r\n\r\n    int id = 0;\r\n\r\n    for (int i = 1; i < A.size(); i++) {\r\n        if (A[i].y == A[id].y && A[i].x < A[id].x) {\r\n            id = i;\r\n        }\r\n        if (A[i].y < A[id].y) {\r\n            id = i;\r\n        }\r\n    }\r\n\r\n    int n = A.size();\r\n\r\n    swap(A[0], A[id]);\r\n\r\n    start = A[0];\r\n\r\n    sort(A.begin() + 1, A.end(), cmp);\r\n\r\n    vector < Point > shell;\r\n\r\n    shell.push_back(A[0]);\r\n    shell.push_back(A[1]);\r\n\r\n    for (int i = 2; i < n; i++) {\r\n\r\n        while (shell.size() > 2) {\r\n\r\n            Vector F(shell[shell.size() - 1], A[i]);\r\n            Vector S(shell[shell.size() - 2], shell[shell.size() - 1]);\r\n\r\n            if ((F ^ S) >= 0) {\r\n                shell.pop_back();\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n\r\n        shell.push_back(A[i]);\r\n    }\r\n\r\n    return shell;\r\n}\r\n\r\nlong double eps = 0.0000001;\r\n\r\nint main() {\r\n    long double rp, hp, rs, hs;\r\n    cin >> rp >> hp >> rs >> hs;\r\n\r\n    Point P = { 0, hp }, S = { 0, hp + hs };\r\n\r\n    long double l = 0, r = 1e12;\r\n    while (r - l > eps) {\r\n        long double mid = (r + l) / 2;\r\n\r\n        Point t = { mid, 0 };  // \u0441\u0442\u0440\u043e\u0438\u043c \u0442\u0440\u0435\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a \u0432\u0435\u0440\u0448\u0438\u043d\u044b \u043a\u043e\u0442\u043e\u0440\u043e\u0433\u043e: \u0446\u0435\u043d\u0442\u0440 \u0448\u0430\u0440\u0438\u043a\u0430, \u043f\u044f\u0442\u0430\u0447\u043e\u043a, \u0442\u043e\u0447\u043a\u0430 \u043a\u0430\u0441\u0430\u043d\u0438\u044f \u0448\u0430\u0440\u0438\u043a\u0430 \u0438\r\n                                                                                          // \u0432\u044b\u0441\u0442\u0440\u0435\u043b\u0430 \u043f\u044f\u0442\u0430\u0447\u043a\u0430\r\n        long double a = t.dist(S);\r\n        long double b = sqrtl(a * a - rs * rs);\r\n        long double cos = b / a;\r\n\r\n        Point e = { S.x * cos + S.y * cos, S.y * cos - S.x * cos };  // \"\u0441\u0434\u0432\u0438\u0433\u0430\u0435\u043c \u0442\u043e\u0447\u043a\u0443\"\r\n        line L = { t, e };       // \u0441\u0442\u0440\u043e\u0438\u043c \u043f\u0440\u044f\u043c\u0443\u044e\r\n\r\n        long double D = L.dist_to_line(P);\r\n        if (D > rp) {\r\n            r = mid;\r\n        }\r\n        else {\r\n            l = mid;\r\n        }\r\n    }\r\n\r\n    cout << fixed << setprecision(10) << l;\r\n}",
    "YaraRule": [
        "enable_org32",
        "core_keywords"
    ]
}